/*
 * ArduPilot compatibility typedefs using the Eigen library
 * @authors: Daniel Frenzel <dgdanielf@gmail.com>
 */
 
using namespace AP_Eigen;
 

template <class T>
const T &Compat_Vector2<T>::x() const { 
    return (*this)[0]; 
}

template <class T>
const T &Compat_Vector2<T>::y() const { 
    return (*this)[1]; 
}

// CTORs
template <class T>
Compat_Vector2<T>::Compat_Vector2() : CompatBase_Vector2<T>(Compat_Vector2::Zero(2)) {
}

template <class T>
template <class OtherDerived>
Compat_Vector2<T>::Compat_Vector2(const Eigen::MatrixBase<OtherDerived>& other) : CompatBase_Vector2<T>(other) { 
}

template <class T>
template <class OtherDerived>
Compat_Vector2<T>::Compat_Vector2(const Vector2<OtherDerived> &v) : CompatBase_Vector2<T>(v.x, v.y) { 
}

template <class T>
Compat_Vector2<T>::Compat_Vector2(const T &sx, const T &sy) : CompatBase_Vector2<T>(sx, sy) { 
}

// type operators
template <class T>
template <class OtherDerived>
Compat_Vector2<T>::operator Vector2<OtherDerived>() const {
    return Vector2<OtherDerived>((*this)[0], (*this)[1] );
}

template <class T>
Compat_Vector2<T> &Compat_Vector2<T>::operator=(const Vector2<T> &other) {
    if (this != &other) {
        (*this)[0] = other.x;
        (*this)[1] = other.y;
    }
    return *this;
} 

template <class T>
const T &Compat_Vector3<T>::x() const { 
    return (*this)[0]; 
}

template <class T>
const T &Compat_Vector3<T>::y() const { 
    return (*this)[1]; 
}

template <class T>
const T &Compat_Vector3<T>::z() const { 
    return (*this)[2]; 
}

template <class T>
Compat_Vector3<T>::Compat_Vector3() : CompatBase_Vector3<T>(Compat_Vector3::Zero(3)) { 
}

template <class T>
template <class OtherDerived>
Compat_Vector3<T>::Compat_Vector3(const Eigen::MatrixBase<OtherDerived>& other) : CompatBase_Vector3<T>(other) { 
}

template <class T>
template <class OtherDerived>
Compat_Vector3<T>::Compat_Vector3(const Vector3<OtherDerived> &v) : CompatBase_Vector3<T>(v.x, v.y, v.z) { 
}

template <class T>
Compat_Vector3<T>::Compat_Vector3(const T &sx, const T &sy, const T &sz) : CompatBase_Vector3<T>(sx, sy, sz) { 
}

template <class T>
template <class OtherDerived>
Compat_Vector3<T>::operator Vector3<OtherDerived>() const {
    return Vector3<OtherDerived>((*this)[0], (*this)[1], (*this)[2]);
}

template <class T>
Compat_Vector3<T> &Compat_Vector3<T>::operator=(const Vector3<T> &other) {
    (*this)[0] = other.x;
    (*this)[1] = other.y;
    (*this)[2] = other.z;
    return *this;
}

template <class T>
Compat_Matrix3<T>::Compat_Matrix3() : CompatBase_Matrix3<T>(Compat_Matrix3::Zero(3,3)) { 
  
}

template <class T>
template <class OtherDerived>
Compat_Matrix3<T>::Compat_Matrix3(const Eigen::MatrixBase<OtherDerived>& other) : CompatBase_Matrix3<T>(other) { 
  
}

template <class T>
template <class OtherDerived>
Compat_Matrix3<T>::Compat_Matrix3(const Matrix3<OtherDerived>& m) : CompatBase_Matrix3<T>() {
    (*this) <<  m.a.x, m.a.y, m.a.z,
                m.b.x, m.b.y, m.b.z,
                m.c.x, m.c.y, m.c.z;
}

template <class T>
Compat_Matrix3<T>::Compat_Matrix3(T ax, T ay, T az, T bx, T by, T bz, T cx, T cy, T cz) : CompatBase_Matrix3<T>() {          
    (*this) <<  ax, ay, az,
                bx, by, bz,
                cx, cy, cz;
}

template <class T>
template <class OtherDerived>
Compat_Matrix3<T>::operator Matrix3<OtherDerived>() const {
    OtherDerived ax = (*this)(0,0);
    OtherDerived ay = (*this)(0,1);
    OtherDerived az = (*this)(0,2);

    OtherDerived bx = (*this)(1,0);
    OtherDerived by = (*this)(1,1);
    OtherDerived bz = (*this)(1,2);

    OtherDerived cx = (*this)(2,0);
    OtherDerived cy = (*this)(2,1);
    OtherDerived cz = (*this)(2,2);
    
    return Matrix3<OtherDerived>(ax, ay, az, 
                                  bx, by, bz, 
                                  cx, cy, cz);
}      

template <class T>
Compat_Matrix3<T> &Compat_Matrix3<T>::operator=(const Matrix3<T> &other) {
    (*this)(0,0) = other.a.x;
    (*this)(0,1) = other.a.y;
    (*this)(0,2) = other.a.z;
    
    (*this)(1,0) = other.b.x;
    (*this)(1,1) = other.b.y;
    (*this)(1,2) = other.b.z;
    
    (*this)(2,0) = other.c.x;
    (*this)(2,1) = other.c.y;
    (*this)(2,2) = other.c.z;

    return *this;
}
